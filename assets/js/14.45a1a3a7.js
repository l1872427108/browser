(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{413:function(t,v,a){"use strict";a.r(v);var _=a(56),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"dom和vnode的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom和vnode的不同"}},[t._v("#")]),t._v(" DOM和VNode的不同")]),t._v(" "),a("h3",{attrs:{id:"dom-的缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-的缺陷"}},[t._v("#")]),t._v(" DOM 的缺陷")]),t._v(" "),a("p",[t._v("通过 js 来操纵 DOM 会影响到整个渲染流水线。")]),t._v(" "),a("p",[t._v("对于简单的页面来说，DOM 结构比较简单，操作 DOM 对用户的体验不会产生太大的影响。但是对于复杂的页面或者非常火的单页应用来说，DOM 结构是非常复杂的。需要不断的修改 DOM。都会引起重排、重绘或者合成操作。")]),t._v(" "),a("h3",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("ul",[a("li",[t._v("页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM上。")]),t._v(" "),a("li",[t._v("虚拟 DOM 不会直接去渲染页面，而是进行比对找到需要改动的部分。")]),t._v(" "),a("li",[t._v("在虚拟 DOM 收集到足够的改变，才会一次性的应用到真实的 DOM。")])]),t._v(" "),a("h3",{attrs:{id:"从双缓存视角来看虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从双缓存视角来看虚拟dom"}},[t._v("#")]),t._v(" 从双缓存视角来看虚拟DOM")]),t._v(" "),a("p",[t._v("屏幕是从前缓冲区读取数据然后显示，比如一整个页面，需要多次才能完成。如果直接放入前缓冲区，就会一部分一部分显示出来，让用户感到页面的闪烁。常用来解决无效刷新和闪屏问题。")]),t._v(" "),a("p",[t._v("使用双缓存，可以将计算的中间结果存放到另一个缓冲区中，等全部计算完成，在一次性的复制到前缓冲区。")]),t._v(" "),a("p",[t._v("虚拟DOM 也是会在完成一次性操作之后，再将结果应用到 DOM, 减少不必要的更新。")]),t._v(" "),a("h3",{attrs:{id:"mvc模式看虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc模式看虚拟dom"}},[t._v("#")]),t._v(" MVC模式看虚拟DOM")]),t._v(" "),a("p",[t._v("我们把虚拟DOM看作是 MVC 的视图部分。控制器和模型都是由Vue提供。")]),t._v(" "),a("ul",[a("li",[t._v("监控到 DOM 变化，一旦 DOM 发生变化，控制器就会通知模型，让其更新数据。")]),t._v(" "),a("li",[t._v("模型数据更新好之后，根据数据来生成新的虚拟DOM。")]),t._v(" "),a("li",[t._v("比对。触发DOM节点更新。")]),t._v(" "),a("li",[t._v("一次性触发渲染流水线。")])]),t._v(" "),a("p",[t._v("前端框架，离不开设计模式。基于MVC的设计思想广泛的渗透到各种场合，并且基于MVC衍生出很多其他模式（MVP、MVVM等）。")])])}),[],!1,null,null,null);v.default=s.exports}}]);