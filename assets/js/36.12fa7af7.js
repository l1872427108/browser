(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{434:function(a,e,t){"use strict";t.r(e);var v=t(56),_=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),t("p",[a._v("浏览器缓存可以分为两种：一种是需要发送 HTTP 请求，一种不需要发送.")]),a._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),t("p",[a._v("检查强缓存，不需要进行发送 HTTP 请求。 在相应的字段来进行检查。")]),a._v(" "),t("p",[a._v("在 HTTP/1.0 和 HTTP/1.1 ，强缓存的字段是不一样的。")]),a._v(" "),t("p",[a._v("在 HTTP/1.0 阶段，使用的是 Expires 字段。在 HTTP/1.1 阶段使用 Cache-Control 字段.")]),a._v(" "),t("h3",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),t("p",[a._v("Expires 存在于服务端返回的响应头中，告诉浏览器在这个过期时间之间可以从缓存中去获取数据，不用在此请求。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Expires: Wed, 22 Nov 2019 09:41:00 GMT\n")])])]),t("p",[a._v("表示资源将在 xxxx年xxxx月xxxx日资源过期。")]),a._v(" "),t("p",[a._v("但是这种存在一个问题就是：对于客户端和服务器的时间是不一致的，服务器和浏览器的时间并不一致。所以在 HTTP/1.1 中就抛弃了。")]),a._v(" "),t("h3",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),t("p",[a._v("Cache-Control 是不一样的，它并没有像 Expires 一样设置的是时间点，而是通过时长来控制的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Cache-Control:max-age=3600\n")])])]),t("p",[a._v("则会在 3600 秒之后过期，也就是 1 个小时内过期。")]),a._v(" "),t("p",[a._v("并且 Cache-Control 上有很多的属性的，可以组成多种形式，完成多种场景的判断。")]),a._v(" "),t("ol",[t("li",[a._v("public：对于客户端和代理服务器都可以设置缓存。 因为一个请求，可能经过多个代理服务器才能够到达服务器，不管是浏览器可以被缓存，任何一个代理服务器都可以被缓存。")]),a._v(" "),t("li",[a._v("private: 能够缓存的就只有是浏览器了，而没有代理服务器。")]),a._v(" "),t("li",[a._v("no-cache: 跳过强缓存，进行 HTTP 请求，进入协商缓存阶段。")]),a._v(" "),t("li",[a._v("no-store: 不会进行任何形式的缓存。")]),a._v(" "),t("li",[a._v("s-maxage: 是针对于代理服务器的缓存时间段。")])]),a._v(" "),t("h3",{attrs:{id:"强缓存过期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存过期"}},[a._v("#")]),a._v(" 强缓存过期")]),a._v(" "),t("p",[a._v("当强缓存过期之后，就会进入到协商缓存阶段。")]),a._v(" "),t("h3",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),t("p",[a._v("当强缓存过期之后，浏览器就会携带上缓存tag，发送 HTTP，服务器接收到之后，会根据缓存 tag 去决定是否使用缓存，这就是协商缓存。")]),a._v(" "),t("h3",{attrs:{id:"last-modified"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),t("p",[a._v("代表的是最后的修改时间，浏览器在请求服务器之后，服务器的响应就会带上 Last-Modified 这个字段。")]),a._v(" "),t("p",[a._v("当下一次浏览器需要请求头携带 If-Modified-Since 这个字段，这个字段的值就是浏览器返回的最后修改时间。")]),a._v(" "),t("p",[a._v("浏览器拿到这个值后，会与该资源的最后修改时间会进行比较：")]),a._v(" "),t("ol",[t("li",[a._v("如果请求头中的时间是小于最后修改的时间，代表是时候进行更新了，就会像正常的 HTTP 请求一样去返回响应。")]),a._v(" "),t("li",[a._v("否则返回 304，告诉浏览器直接去缓存拿取资源。")])]),a._v(" "),t("h3",{attrs:{id:"etag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" ETag")]),a._v(" "),t("p",[a._v("服务器会根据资源内容生成一个唯一标识，只要内容不发送变化，这个标识就不会改变。")]),a._v(" "),t("p",[a._v("浏览器在请求的时候，会携带这个 If-None-Match 这个字段内容。")]),a._v(" "),t("p",[a._v("服务器拿到这个字段之后，就会与资源的 ETag 进行比较：")]),a._v(" "),t("ol",[t("li",[a._v("如果两者不一样，代表要进行跟新了，跟正常HTTP响应一样，返回响应。")]),a._v(" "),t("li",[a._v("否则返回 304，告诉浏览器去直接拿取缓存。")])]),a._v(" "),t("h3",{attrs:{id:"last-modified-和-etag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-和-etag"}},[a._v("#")]),a._v(" Last-Modified 和 ETag")]),a._v(" "),t("p",[a._v("都是进行协商缓存的。")]),a._v(" "),t("p",[a._v("精度上：\nLast-Modified：")]),a._v(" "),t("ol",[t("li",[a._v("是针对于内容修改时间的，加入一条空行，也会表示内容进行更新了，缓存也会失效的。")]),a._v(" "),t("li",[a._v("它的修改是对于秒来说的，只要 1 秒之内修改很多的文件，服务器是不会觉得修改过文件的，这样就会继续走缓存。")])]),a._v(" "),t("p",[a._v("ETag：")]),a._v(" "),t("ol",[t("li",[a._v("是针对于内容来说的，只要内容不更新，就会走缓存.")])]),a._v(" "),t("p",[a._v("性能上\nLast-Modified 只需要记录一个时间点。\nETag 要根据所有的内容生成具体内容的哈希值。")]),a._v(" "),t("h3",{attrs:{id:"缓存的位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存的位置"}},[a._v("#")]),a._v(" 缓存的位置")]),a._v(" "),t("p",[a._v("当被强缓存或协商缓存命中，就会返回 304，然后直接从缓存中获取。")]),a._v(" "),t("ol",[t("li",[a._v("Service Worker")]),a._v(" "),t("li",[a._v("Memory Cache")]),a._v(" "),t("li",[a._v("Disk Cache")]),a._v(" "),t("li",[a._v("Push Cache")])]),a._v(" "),t("h3",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),t("p",[a._v("Service Worker 借鉴了 Web Worker ，能够让 JS 运行在主线程之外，由于它脱离了浏览器窗口，不能够操作 DOM，依然可以进行离线缓存，消息推送，网络代理。")]),a._v(" "),t("p",[a._v("离线缓存 就是 Service Worker Cache.")]),a._v(" "),t("h3",{attrs:{id:"memory-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[a._v("#")]),a._v(" Memory Cache")]),a._v(" "),t("p",[a._v("是指内存缓存，从效率上来说是最快的，但是存活时间短，当渲染进程结束之后，内存缓存就会消失。")]),a._v(" "),t("h3",{attrs:{id:"disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[a._v("#")]),a._v(" Disk Cache")]),a._v(" "),t("p",[a._v("是指存储在磁盘中的缓存，从效率上来说是慢于内存缓存的，它的优势是它的存储时长和存储大小。")]),a._v(" "),t("h3",{attrs:{id:"浏览器如何决定将资源放入-memory-cache-还是-disk-cache-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何决定将资源放入-memory-cache-还是-disk-cache-缓存"}},[a._v("#")]),a._v(" 浏览器如何决定将资源放入 Memory Cache 还是 Disk Cache 缓存?")]),a._v(" "),t("ol",[t("li",[a._v("比较大的 JS、CSS 直接丢入磁盘，否则放入内存。")]),a._v(" "),t("li",[a._v("内存使用率较高时，会优先进入磁盘。")])]),a._v(" "),t("h3",{attrs:{id:"push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),t("p",[a._v("是推送缓存，是 HTTP/2 中的内容。")])])}),[],!1,null,null,null);e.default=_.exports}}]);