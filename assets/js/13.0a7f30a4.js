(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{409:function(t,v,e){"use strict";e.r(v);var _=e(56),i=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"chrome的audits面板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome的audits面板"}},[t._v("#")]),t._v(" Chrome的Audits面板")]),t._v(" "),e("p",[t._v("基于浏览器整体优化，我们页面交互阶段的性能。")]),t._v(" "),e("p",[t._v("我们就需要有监控 Web 应用的性能数据，那怎么监控呢？")]),t._v(" "),e("p",[t._v("Chrome 为我们提供了非常完善的性能检测工具：Performance 和 Audits")]),t._v(" "),e("p",[t._v("它们能够准确统计页面在加载阶段和运行阶段的一些核心数据，诸如任务执行记录、首屏展示花费的时长等，有了这些数据我们就能很容易定位到 Web 应用的性能瓶颈 。")]),t._v(" "),e("p",[t._v("Performance 非常强大，因为它为我们提供了非常多的运行时数据,利用这些数据我们就可以分析出来 Web 应用的瓶颈。但是要完全学会其使用方式却是非常有难度的，其难点在于这些数据涉及到了特别多的概念，而这些概念又和浏览器的系统架构、消息循环机制、渲染流水线等知识紧密联系在了一起。")]),t._v(" "),e("p",[t._v("Audtis 就简单了许多，它将检测到的细节数据隐藏在背后, 只提供给我们一些直观的性能数据, 同时，还会给我们提供一些优化建议。")]),t._v(" "),e("p",[t._v("Perfomance 能让我们看到更多细节数据，但是更加复杂，Audits 就比较智能，但是隐藏了更多细节。")]),t._v(" "),e("p",[t._v("然后我们需要在 Chrome 的隐身模式下工作，这样可以确保我们安装的扩展、浏览器缓存、Cookie 等数据不会影响到检测结果。")]),t._v(" "),e("p",[t._v("利用 Audits 生成 Web 性能报告")]),t._v(" "),e("p",[t._v("根据性能报告优化 Web 性能")]),t._v(" "),e("ol",[e("li",[t._v("首次绘制 (First Paint)；")]),t._v(" "),e("li",[t._v("首次有效绘制 (First Meaningfull Paint)；")]),t._v(" "),e("li",[t._v("首屏时间 (Speed Index)；")]),t._v(" "),e("li",[t._v("首次 CPU 空闲时间 (First CPU Idle)；")]),t._v(" "),e("li",[t._v("完全可交互时间 (Time to Interactive)；")]),t._v(" "),e("li",[t._v("最大估计输入延时 (Max Potential First Input Delay)。")])]),t._v(" "),e("p",[t._v("这六项都是页面在加载过程中的性能指标，所以要弄明白这六项指标的具体含义，我们还得结合页面的加载过程来分析。\n我们还是先看下面这张页面从加载到展示的过程图：")]),t._v(" "),e("p",[t._v("在渲染进程确认要渲染当前的请求后, 渲染进程会创建一个空白页面, 我们把创建空白页面的这个时间点称为 First Paint，简称 FP。")]),t._v(" "),e("p",[t._v("然后渲染进程继续请求关键资源, 并且知道了关键资源包括了 JavaScript 文件和 CSS 文件，因为关键资源会阻塞页面的渲染，所以我们需要等待关键资源加载完成后，才能执行进一步的页面绘制。")]),t._v(" "),e("p",[t._v("bundle.js 是关键资源，因此需要完成加载之后，渲染进程才能执行该脚本，然后脚本会修改 DOM，引发重绘和重排等一系列操作，当页面中绘制了第一个像素时，我们把这个时间点称为 First Content Paint，简称 FCP。")]),t._v(" "),e("p",[t._v("接下来继续执行 JavaScript 脚本，当首屏内容完全绘制完成时，我们把这个时间点称为 Largest Content Paint，简称 LCP。")]),t._v(" "),e("p",[t._v("在 FCP 和 LCP 中间，还有一个 FMP，这个是首次有效绘制，由于 FMP 计算复杂，而且容易出错，现在不推荐使用该指标，所以这里我们也不做过多介绍了。")]),t._v(" "),e("p",[t._v("接下来 JavaScript 脚本执行结束，渲染进程判断该页面的 DOM 生成完毕，于是触发 DOMContentLoad 事件。等所有资源都加载结束之后，再触发 onload 事件。")]),t._v(" "),e("p",[t._v("好了，以上就是页面在加载过程中各个重要的时间节点，了解了这些时间节点，我们就可以来聊聊性能报告的六项指标的含义并讨论如何优化这些指标。")]),t._v(" "),e("p",[t._v("我们先来分析下第一项指标 FP，如果 FP 时间过久，那么直接说明了一个问题，那就是页面的 HTML 文件可能由于网络原因导致加载时间过久")]),t._v(" "),e("p",[t._v("第三项是首屏时间 (Speed Index)，这就是我们上面提到的 LCP，它表示填满首屏页面所消耗的时间，首屏时间的值越大，那么加载速度越慢，具体的优化方式同优化第二项 FMP 是一样。")]),t._v(" "),e("p",[t._v("第四项是首次 CPU 空闲时间 (First CPU Idle)，也称为 First Interactive，它表示页面达到最小化可交互的时间，也就是说并不需要等到页面上的所有元素都可交互，只要可以对大部分用户输入做出响应即可。要缩短首次 CPU 空闲时长，我们就需要尽可能快地加载完关键资源，尽可能快地渲染出来首屏内容，因此优化方式和第二项 FMP 和第三项 LCP 是一样的。")]),t._v(" "),e("p",[t._v("第五项是完全可交互时间 (Time to Interactive)，简称 TTI，它表示页面中所有元素都达到了可交互的时长。简单理解就这时候页面的内容已经完全显示出来了，所有的 JavaScript 事件已经注册完成，页面能够对用户的交互做出快速响应，通常满足响应速度在 50 毫秒以内。如果要解决 TTI 时间过久的问题，我们可以推迟执行一些和生成页面无关的 JavaScript 工作。")]),t._v(" "),e("p",[t._v("第六项是最大估计输入延时 (Max Potential First Input Delay），这个指标是估计你的 Web 页面在加载最繁忙的阶段， 窗口中响应用户输入所需的时间，为了改善该指标，我们可以使用 WebWorker 来执行一些计算，从而释放主线程。另一个有用的措施是重构 CSS 选择器，以确保它们执行较少的计算。")])])}),[],!1,null,null,null);v.default=i.exports}}]);