(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{435:function(n,v,_){"use strict";_.r(v);var e=_(56),t=Object(e.a)({},(function(){var n=this,v=n.$createElement,_=n._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器的执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的执行过程"}},[n._v("#")]),n._v(" 浏览器的执行过程")]),n._v(" "),_("p",[n._v("从输入URL到加载，我们可以看出来页面的渲染。\n这个是从Chrome浏览器的架构上来分析的。 进程和线程上.")]),n._v(" "),_("p",[n._v("我们知道了什么时候去下载交给什么进程。")]),n._v(" "),_("p",[n._v("但是对于 html、css、js下载回来来解析不是进程来做的。")]),n._v(" "),_("p",[n._v("是浏览器内核来帮助我们解析的。")]),n._v(" "),_("ul",[_("li",[n._v("Gecko")]),n._v(" "),_("li",[n._v("Trident IE4-IE11 ,  Edge是用的Blink.")]),n._v(" "),_("li",[n._v("Webkit 苹果基于KHTML, Safari、Google之前也在使用。")]),n._v(" "),_("li",[n._v("Blink: 是 Webkit 的一个分支，Google开发，应用于 Google、Edge、Opera等")])]),n._v(" "),_("p",[n._v("浏览器引擎、排版引擎。")]),n._v(" "),_("p",[n._v("会对HTML解析，遇到CSS下载，遇到JS加载js代码.")]),n._v(" "),_("h3",{attrs:{id:"js-代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js-代码"}},[n._v("#")]),n._v(" js 代码")]),n._v(" "),_("p",[n._v("是由js引擎来执行的。")]),n._v(" "),_("p",[n._v("高级语言，需要被CPU来执行。")]),n._v(" "),_("p",[n._v("CPU只认识自己的指令集")]),n._v(" "),_("h3",{attrs:{id:"js引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js引擎"}},[n._v("#")]),n._v(" js引擎")]),n._v(" "),_("ul",[_("li",[n._v("SpiderMonkey: js作者开发。")]),n._v(" "),_("li",[n._v("Chakra: 微软开发，IE。")]),n._v(" "),_("li",[n._v("JavaScriptCore: Webkit中内置的，Apple公司开发。")]),n._v(" "),_("li",[n._v("V8: Google开发的js引擎。\n...")])]),n._v(" "),_("h3",{attrs:{id:"v8引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎"}},[n._v("#")]),n._v(" V8引擎")]),n._v(" "),_("p",[n._v("用C++，一百多万行代码写成，V8可以独立运行，潜入能够执行js。")]),n._v(" "),_("h3",{attrs:{id:"v8架构图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8架构图"}},[n._v("#")]),n._v(" V8架构图")]),n._v(" "),_("p",[n._v("js源代码 ---\x3e Parse  ----\x3e AST")]),n._v(" "),_("p",[n._v("可以将抽象语法书转为字节码")]),n._v(" "),_("p",[n._v("AST ----\x3e Ignition ---\x3e bytecode ---\x3e 执行")]),n._v(" "),_("h3",{attrs:{id:"转为字节码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转为字节码"}},[n._v("#")]),n._v(" 转为字节码")]),n._v(" "),_("p",[n._v("js跑在什么环境下不一定。 windows/mac/linux 的浏览器上面。")]),n._v(" "),_("p",[n._v("跑在不同的环境有不同的CPU架构。 能够执行的机器指令是不一样的。")]),n._v(" "),_("p",[n._v("V8会将字节码转位不同平台的机器码。")]),n._v(" "),_("h3",{attrs:{id:"优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[n._v("#")]),n._v(" 优化")]),n._v(" "),_("p",[n._v("TuboFan 来收集执行信息， 标记 hot 热点代码。")]),n._v(" "),_("p",[n._v("TuboFan ----\x3e 优化后机器码  ---\x3e 运行结果。")]),n._v(" "),_("p",[n._v("Deoptimization 反优化。 下次热点代码的执行操作不一样的。")]),n._v(" "),_("h3",{attrs:{id:"内核和v8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核和v8"}},[n._v("#")]),n._v(" 内核和V8")]),n._v(" "),_("p",[n._v("Blink 将下载源码讲给 V8，Stream获取到源码进行编码转换。")]),n._v(" "),_("p",[n._v("Scaaner 进行词法分析, 词法分析会将代码转为 tokens。")]),n._v(" "),_("p",[n._v("Tokens 经过Parser和PreParser, 会被转为 AST 树.")]),n._v(" "),_("p",[n._v("一次性解析，会影响性能。")]),n._v(" "),_("p",[n._v("PreParser称为预解析，V8引擎实现了Lazy Parsing(延迟解析)的方案。将不必要的函数进行预解析。函数调用在进行全量解析。")]),n._v(" "),_("h3",{attrs:{id:"js执行前的工作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js执行前的工作"}},[n._v("#")]),n._v(" JS执行前的工作")]),n._v(" "),_("p",[n._v("Parse 解析的时候就会创建一个 GlobalObject = {}   GO")]),n._v(" "),_("p",[n._v('var globalObject = {\nString: "类",\nDate: \'类\',\nsetTimeout: "函数",\nwindow: globalObject,\nname: undefined\n}')]),n._v(" "),_("p",[n._v("window.window.window")]),n._v(" "),_("p",[n._v("会将属性放到GO上。")]),n._v(" "),_("h3",{attrs:{id:"运行代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行代码"}},[n._v("#")]),n._v(" 运行代码")]),n._v(" "),_("p",[n._v("V8执行代码，内部会有一个执行上下文栈。")]),n._v(" "),_("p",[n._v("全局代码，为了全局代码能够正常的执行，会创建一个全局上下文。")]),n._v(" "),_("p",[n._v("当前上下文的 VO 变量对象  会指向 GO.")]),n._v(" "),_("p",[n._v("开始执行代码 VO 找到 GO，修改 GO 的值。")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("有函数情况")]),n._v(" "),_("p",[n._v("编译到函数，并不会执行，而是先会开辟一块内存空间 0xa00， GlobalObject 的 foo 指向 0xa00 地址。")]),n._v(" "),_("p",[n._v("0xa00 里面会包含 [[scope]]: parent scope  、 函数执行代码块")]),n._v(" "),_("p",[n._v("执行代码 foo() ，就会找到foo的地址，在上下文栈中先创建一个函数执行上下文。FEC.")]),n._v(" "),_("p",[n._v("有了执行上下文 会创建一个VO。  VO:AO    AO = {}会被销毁.")]),n._v(" "),_("p",[n._v("AO(Activation Object)活跃对象：来收集函数内部参数变量。")]),n._v(" "),_("p",[n._v("创建一个AO,  AO = {name: undefined, m: undefined, n: undefined}")]),n._v(" "),_("p",[n._v("执行代码，就会去 VO 中查找  ----\x3e AO")]),n._v(" "),_("p",[n._v("执行完之后就会弹出去。 没有指向 AO 就会被销毁掉")]),n._v(" "),_("h3",{attrs:{id:"变量查找规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量查找规则"}},[n._v("#")]),n._v(" 变量查找规则")]),n._v(" "),_("p",[n._v("当前VO中没有的话。")]),n._v(" "),_("p",[n._v("查找变量的查找路径是沿着作用域链查找")]),n._v(" "),_("p",[n._v("VO、scope chain：VO + parent scope")]),n._v(" "),_("p",[n._v("函数被编译的时候就会确定[[scope]]")]),n._v(" "),_("h3",{attrs:{id:"函数嵌套"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数嵌套"}},[n._v("#")]),n._v(" 函数嵌套")]),n._v(" "),_("h3",{attrs:{id:"变量环境和记录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量环境和记录"}},[n._v("#")]),n._v(" 变量环境和记录")]),n._v(" "),_("p",[n._v("AO\\GO\nVO:GO\nVO:AO"),_("br"),n._v("\n早期 ECMASCript5 以前")]),n._v(" "),_("p",[n._v("每创建一个执行上下文都会关联到变量对象上VO,")]),n._v(" "),_("p",[n._v("如果声明变量或函数会作为属性添加到VO上,")]),n._v(" "),_("p",[n._v("对于函数来说，参数也会被添加到VO上.")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("ECMASCript5 之后")]),n._v(" "),_("p",[n._v("每创建一个执行上下文都会关联到变量环境中，")]),n._v(" "),_("p",[n._v("在执行代码中变量和函数的声明会作为环境记录添加到变量环境中。")]),n._v(" "),_("p",[n._v("VE：enerentcoment recode   一条环境记录  可以使用对象还是Map都可以")]),n._v(" "),_("h3",{attrs:{id:"内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[n._v("#")]),n._v(" 内存管理")]),n._v(" "),_("p",[n._v("不管什么样的编程语言，在代码执行过程中都是需要分配内存的，不同的是\n某些编程语言需要我们手动的管理内存")]),n._v(" "),_("p",[n._v("代码  磁盘 ---\x3e 内存  ---\x3e CPU")]),n._v(" "),_("p",[n._v("执行过程中会继续开辟空间")]),n._v(" "),_("p",[n._v("变量和函数 的分配方式：")]),n._v(" "),_("ol",[_("li",[n._v("基本数据类型 栈")]),n._v(" "),_("li",[n._v("复杂数据类型 堆")])]),n._v(" "),_("p",[n._v("Js的内存结构")]),n._v(" "),_("p",[n._v("现在大部分的编程语言有垃圾回收机制   GC\n对于不再使用的对象，就会被回收, 释放更多的内存空间。\nJavaScript 的js引擎也有垃圾回收器")]),n._v(" "),_("p",[n._v("GC算法:")]),n._v(" "),_("ol",[_("li",[n._v("引用计数\nretain count: 0      +1     +1  ----\x3e  2   本身栈中有1  3\ninfo.friend = null        -1\n变为0 就会被释放")])]),n._v(" "),_("p",[n._v("存在问题： 弊端循环引用")]),n._v(" "),_("p",[n._v("var obj1 = {friend:obj2}\nvar obj2 = {friend:obj1}")]),n._v(" "),_("p",[n._v("obj.friend = null;")]),n._v(" "),_("p",[n._v("一直不会清空 就会造成内存泄露")]),n._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[n._v("标记清除  可以很好的解决循环引用的问题\n设置一个根对象 root object, 从根开始查找所有的对象")])]),n._v(" "),_("p",[n._v("js引擎采用的就是标记清除算法，当然类似V8引擎为了进行更好的优化，在算法的\n细节上也会有不同的算法。")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("JS中函数是一等公民\n参数传递、返回值")]),n._v(" "),_("p",[n._v("高阶函数：把一个函数如果接受另一个函数作为参数，或者返回一个函数就叫高结函数")]),n._v(" "),_("p",[n._v("reduce 累加\n[10, 5, 11, 100, 55]\nvar total = 0;\nfor (var i = 0; i < nums.length; i++) {\ntotal += nums[i];\n}\nprevValue 0    item 10\nprevValue 10   item 5\nprevValue")]),n._v(" "),_("p",[n._v("5次")]),n._v(" "),_("p",[n._v("nums.reduce((prevValue, item) => {\nreturn preVal + item;\n}, 0);")]),n._v(" "),_("h3",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),_("p",[n._v("Js中闭包的定义: 在计算机科学和js中")]),n._v(" "),_("p",[n._v("头等函数：函数作为第一公民")]),n._v(" "),_("p",[n._v("Js -> 对象 存储了一个函数和关联的环境, 相当于一个符号查找表")]),n._v(" "),_("p",[n._v("当捕捉闭包的时候，它的自由变量会在捕捉时确定，即使脱离捕捉的上下文，能正常运行。")]),n._v(" "),_("p",[n._v("闭包：函数 + 可以访问的自由变量")]),n._v(" "),_("p",[n._v("闭包是一个结构体，存储了函数和一个关联的环境")]),n._v(" "),_("p",[n._v("实现词法绑定的一种技术 词法解析的时候就已经确定了作用域")]),n._v(" "),_("p",[n._v("可以访问和必须访问")]),n._v(" "),_("h3",{attrs:{id:"为什么ao没有销毁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么ao没有销毁"}},[n._v("#")]),n._v(" 为什么AO没有销毁?")]),n._v(" "),_("ol",[_("li",[n._v("Foo: AO 没有销毁？")]),n._v(" "),_("li",[n._v("闭包为什么存在内存泄露")])]),n._v(" "),_("p",[n._v("函数执行过程的内存？")]),n._v(" "),_("p",[n._v("堆内存中")]),n._v(" "),_("p",[n._v("GO 提前创建好")]),n._v(" "),_("p",[n._v("执行栈  ECStack")]),n._v(" "),_("p",[n._v("全局代码 全局执行执行上下文")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("内存变量\n可以通过性能分析工具查看内存变化。")]),n._v(" "),_("p",[n._v("销毁 没有引用的自由变量 AO 中是会被销毁的  debugger 和控制台打印查看当前作用域")]),n._v(" "),_("hr"),n._v(" "),_("h3",{attrs:{id:"为什么需要this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要this"}},[n._v("#")]),n._v(" 为什么需要this")]),n._v(" "),_("p",[n._v("java，c++, this只会出现在类的方法中。\n但是js中的this更加灵活，无论是它出现的位置还是代表的含义.")]),n._v(" "),_("p",[n._v("开发中，没有 this ，很多问题也有解决方案； 但是没有this编写代码变得不灵活")]),n._v(" "),_("ol",[_("li",[n._v("this在全局作用于指向\n浏览器：window （globalObject）\nNode环境 {}   文件模块，加载->编译->放到一个函数->执行函数.apply({}) this指向空对象")])]),n._v(" "),_("p",[n._v("函数中使用：\n函数被调用时，创建一个执行上下文\nVO:\nscopechain:\nthis: 动态绑定  执行的时候才能确定")]),n._v(" "),_("p",[n._v("this指向和所处的位置是没有关系的。\nthis根函数被调用的方式是有关的。")]),n._v(" "),_("p",[n._v("默认绑定\n隐式绑定\n显示绑定\nnew绑定")]),n._v(" "),_("p",[n._v("什么独立的执行，没有调用的主体")]),n._v(" "),_("p",[n._v("隐式绑定。\n调用方式是通过某个对象进行调研的。\n执行上下文 this 绑定 就是绑定到这个对象")]),n._v(" "),_("p",[n._v("函数被调起来的时候，函数就有 this")]),n._v(" "),_("p",[n._v("object 对象会被 js 引擎绑定到 fn 函数中 this 里面\n必须在调用的对象内部有一个对函数的引用。\n通过这个引用，间接的将this绑定到了这个对象上。")]),n._v(" "),_("p",[n._v("显示绑定\n不希望在对象内部包含这个函数的引用，")]),n._v(" "),_("p",[n._v("call/apply 可以指定 this 的绑定对象")]),n._v(" "),_("p",[n._v("call/apply 的区别")]),n._v(" "),_("p",[n._v("sum(10, 20);")]),n._v(" "),_("p",[n._v("sum.call('call', 20, 30, 40);")]),n._v(" "),_("p",[n._v("sum.apply('apply', [20, 30, 40])")]),n._v(" "),_("p",[n._v("call 和 apply 在执行函数时，可以明确的绑定 this。 这个绑定规则可以称为显示绑定。")]),n._v(" "),_("p",[n._v("foo.call('aaa');\nfoo.call('aaa');")]),n._v(" "),_("p",[n._v("var newFoo = foo.bind('aaa');")]),n._v(" "),_("p",[n._v("内置函数绑定")]),n._v(" "),_("p",[n._v("new绑定\njs 中函数可以当作类的构建函数来使用。使用 new 关键字\n创建一个全新的对象，这个新对象会绑定到函数调用的 this 上。\n返回这个对象")]),n._v(" "),_("p",[n._v("var p1 = new Person('www', 'red');\nconsole.log();")]),n._v(" "),_("p",[n._v("VO:\nscope Chain\nthis Binging: obj")]),n._v(" "),_("p",[n._v("优先级")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("js: 10 3.14 -> number 8byte\n小的数字类型，在 V8中称为 Sim。小数字 2的32次")]),n._v(" "),_("p",[n._v("函数的 this 分析\n函数内部调用回调函数和内部的调用方式有关")]),n._v(" "),_("p",[n._v("const boxDiv = ;\nboxDiv.onClick = function() {\nconsole.log(this);\n}\nboxDiv.onClick()")]),n._v(" "),_("p",[n._v("boxDiv.addEventListener('click', function () {\nconsole.log(this); // boxDiv\n})\nboxDiv.addEventListener('click', function () {\nconsole.log(this); // boxDiv\n})\nboxDiv.addEventListener('click', function () {\nconsole.log(this);  // boxDiv\n})\n收集起来回调\nfn.call(boxDiv)")]),n._v(" "),_("p",[n._v("数组 forEach/map/filter/find\nvar nmaes = ['abc', 'cba']\nnames.forEach(function() {\nconsole.log(this);  // window 说明就是独立函数调用\n如果想要改变this指向\n}, 'abc');")]),n._v(" "),_("p",[n._v("绑定规则优先级\n比如同时有多个优先级采用哪种规则")]),n._v(" "),_("ol",[_("li",[_("p",[n._v("默认规则优先级最低")])]),n._v(" "),_("li",[_("p",[n._v("显示绑定优先级高于隐式绑定")])]),n._v(" "),_("li",[_("p",[n._v("call/apply 的优先级高于隐式绑定")])]),n._v(" "),_("li",[_("p",[n._v("bind 高于隐式绑定")])]),n._v(" "),_("li",[_("p",[n._v("new优先级高于隐式绑定")])]),n._v(" "),_("li",[_("p",[n._v("new优先级高于显示绑定\nnew不能和apply/call一起使用\nfoo.bind('aaa');\nvar obj = new bar();")])])]),n._v(" "),_("p",[n._v("bind优先级高于call/apply")]),n._v(" "),_("p",[n._v("bind 返回一个新函数，但是执行找到的还是原函数来执行的")]),n._v(" "),_("p",[n._v("忽略显示绑定\nnull或者undefined 显示绑定会变为全局对象")]),n._v(" "),_("p",[n._v("间接函数引用\n(obj1.bar = obj2.bar)()  // 函数的独立调用")]),n._v(" "),_("p",[n._v("箭头函数不会绑定 this、arguments 属性")]),n._v(" "),_("p",[n._v("箭头函数不能作为构造函数来使用的 与new使用会抛出错误")]),n._v(" "),_("p",[n._v("高阶函数在使用时，也可以传入箭头函数")]),n._v(" "),_("p",[n._v("箭头函数简写方法：\n参数只有一个： item => {}\n如果执行体只有一行代码 item => item.id = id\n并且会默认将这行代码的结果返回")]),n._v(" "),_("p",[n._v('简写三 如果箭头函数\nvar bar = () => ({name: "why"})  当成一个整体')]),n._v(" "),_("p",[n._v("应用场景")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("实现 apply、call、bind\n具体内部是 C++ 实现的，可以用 js 来模拟\n实现的是练习函数、this、调用关系、不会过度考虑一些边界情况 edge case\nVue/React/webpack")]),n._v(" "),_("p",[n._v("Function.prototype.call = function(thisArg, ...args) {\n1. 可以在这里执行调用的那个函数 foo\n想办法拿到前面的对象  我这是一个函数， 谁调用我就是谁\n并且保证通用性 能任意拿到前面的函数\nvar fn = this;")]),n._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[n._v("1.5 转换对象  防止它传入的是非对象类型\nNumber/Boolean/String ---\x3e Object\nthisArg = thisArg ? Object(thisArg) : window;\n\n2. 调用需要被执行的函数\nthisArg.fn = fn;\nvar result = thisArg.fn(...args)\n\n3. 删掉\ndelete thisArg.fn\n\nreturn result;\n")])])]),_("p",[n._v("}")]),n._v(" "),_("p",[n._v("展开运算符 spread\nvar newNames = [...names]")]),n._v(" "),_("p",[n._v("Function.prototype.apply = function(thisArg, argArray) {\nvar fn = this;")]),n._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[n._v("thisArg = thisArg == null ? Object(thisArg) : window;\n\n2. 调用需要被执行的函数\nthisArg.fn = fn;\nvar result\n\x3c!-- if (!argArray) {  // 没有参数\n    result = thisArg.fn()\n} else { // 有参数\n    result = thisArg.fn(...argArray)\n} --\x3e\n\nargArray = argArray ? argArray : []  // 三元\nargArray = argArray || [];  // 逻辑或\nresult = thisArg.fn(...argArray)\n\n3. 删掉\ndelete thisArg.fn\n\nreturn result;\n")])])]),_("p",[n._v("}\nfunction foo(num) {\nreturn num;\n}")]),n._v(" "),_("p",[n._v("有参数和没有参数")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("js函数式编程\n纯函数---\x3e 写过、react\nreact 好用灵活")]),n._v(" "),_("p",[n._v("steup -> 函数 -> 便携很多其他逻辑 -> 更接近原声开发 -> 函数")]),n._v(" "),_("p",[n._v("纯函数：此函数在相同的输入值时")]),n._v(" "),_("ol",[_("li",[n._v("相同输入值，产生相同输出")]),n._v(" "),_("li",[n._v("输出和输入值意外的其他信息无关   全局变量/I/O设备")]),n._v(" "),_("li",[n._v("不能有语意上客观察的函数副作用, 比如 触发事件，使输出设备输出，或改变输出值意外事件的内容")])]),n._v(" "),_("p",[n._v("确定的输入，一定会产生确定的输出。\n函数在执行过程中，不能产生副作用")]),n._v(" "),_("p",[n._v("副作用：在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加影响，比如修改了全局变量，修改参数或者外部的存储。")]),n._v(" "),_("p",[n._v("存粹的函数式编程不允许有副作用。 副作用往往是产生 bug 的 温床。")]),n._v(" "),_("p",[n._v("names.slice()\nvar newNames1 = names.slice(0, 3);\nslice 只要传入一个 start/end ,对于同一个数组来说，会返回确定的值。\nslice 函数不会修改原来的数组")]),n._v(" "),_("p",[n._v("splice 相同的输入也有相同的输出\n但是会修改数组对象本身，修改这个操作就是产生的副作用")]),n._v(" "),_("p",[n._v("function foo(num1, num2) {\nreturn num1 * 2 + num2 * num2\n}")]),n._v(" "),_("p",[n._v("function bar() {")]),n._v(" "),_("p",[n._v("}")]),n._v(" "),_("p",[n._v("function baz(info) {\ninfo.age = 100;\n}")]),n._v(" "),_("p",[n._v('var obj = {name: "why", age: 18};\nbaz(obj);\n不是存函数，传入参数之后，内部将参数改变了。obj就不是原来的了。')]),n._v(" "),_("p",[n._v("function test(info) {\nreturn {\n...info,\nage: 100\n}\n}\ntest 是一个纯函数")]),n._v(" "),_("p",[n._v("非常有用\nReact 的函数组建（类组建）\nfunction HelloWorld(props) {\n// 不是存函数\nprops.info = {}\nprops.info.name = 'why'\n}\n<HelloWorld info=\"{}>\nconsole.log(info);  // 可能就会意外的修改")]),n._v(" "),_("p",[n._v("function printInfo(info) {\n// 可以看作是纯函数\nconsole.log(info.name);\n}")]),n._v(" "),_("p",[n._v("纯函数的优势：")]),n._v(" "),_("ol",[_("li",[n._v("可以安心编写和使用")]),n._v(" "),_("li",[n._v("只需要关心这个函数参数和返回值就可以")]),n._v(" "),_("li",[n._v("只需要单纯实现自己的业务逻辑，不需要关心传入的内容。")])]),n._v(" "),_("p",[n._v("React 非常灵活，所有React组建必须像纯函数一样保护它们的props不被修改。")]),n._v(" "),_("p",[n._v("var info = {}\nfunction foo() {\nreturn {...obj, name: 'why'}\n}\nfoo(info);")]),n._v(" "),_("p",[n._v("function setCache(key, info) {\nlocalStorage.setItem(key, info)\n}")]),n._v(" "),_("p",[n._v("纯函数是优势，但不是规定")]),n._v(" "),_("p",[n._v("js 柯里化\n在计算机科学中，颗粒化 currying")]),n._v(" "),_("p",[n._v("把接收多个参数的函数，变成接受一个单一参数的函数，返回接受余下的参数，返回结果是一个新的函数的技术。")]),n._v(" "),_("p",[n._v("如果固定某些参数，将得到剩余参数的一个函数。")]),n._v(" "),_("p",[n._v("只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数。\n这个过程就称为颗粒化。")]),n._v(" "),_("p",[n._v("function add(x, y, z) {\nreturn x + y + z;\n}\nadd(10, 20, 30)")]),n._v(" "),_("p",[n._v("function add(x) {\nreturn function(y) {\nreturn function(z) {\nreturn x + y + z;\n}\n}\n}\nadd(10)(20)(30)")]),n._v(" "),_("p",[n._v("function add2 = x => y => z => x+y+z")]),n._v(" "),_("p",[n._v("转换过程是颗粒化")]),n._v(" "),_("p",[n._v("颗粒化的作用：\n在函数式编程中，我们希望一个个函数处理的问题尽可能单一，而不是将一大堆的处理过程交给一个函数来处理")]),n._v(" "),_("p",[n._v("单一职责原则\n面向对象 -> 类 -> 尽可能完成一件事\nclass App{\nrunApp() {")]),n._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[n._v("}\n")])])]),_("p",[n._v("}")]),n._v(" "),_("p",[n._v("我们就可以将每次传入的参数在单一的函数中进行处理，处理完然后交给下一个函数处理")]),n._v(" "),_("p",[n._v("function add(x, y, z) {\nx = x * 2\ny = y * 2\nz = z * 2\nreturn x + y + z;\n}\n边的非常容积")]),n._v(" "),_("p",[n._v("function sum(x) {\nx = x + 2")]),n._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[n._v("return function(y) {\n    y = y * 2\n    \n    return function(z) {\n        z = z * z\n\n        return x + y + z\n    }\n}\n")])])]),_("p",[n._v("}")]),n._v(" "),_("p",[n._v("创建了三个函数，不能被及时销毁。\nfunction sum(x) {\nreturn x * 2\n}\nfunction m(y) {\nreturn y * 2\n}\nfunction s(z) {\nreturn z * z;\n}\nsum(10) + m(20) + n(30)\n每一个函数处理问题单一\nconsole.log(sum(10)(20)(30))")]),n._v(" "),_("p",[n._v("逻辑复用\nfunction sum(m, n) {")]),n._v(" "),_("p",[n._v("}\n在程序中，把 5 和 另外一个数字相加\nconsole.log(5, 10);")]),n._v(" "),_("p",[n._v("function makeAdder(count) {\nreturn function (num) {\nreturn count + num;\n}\n}\nvar adder5 = makeAdder(5)\nadder5(10)\nadder5(15)\nadder5(20)")]),n._v(" "),_("p",[n._v("function (date, type, message) {\nconsole.log(``)\n}")]),n._v(" "),_("p",[n._v("function hyCurring(fn) {\nfunction curried(...args) {\n// 判断已经接受道的参数个数和已经接受的是否一致\nif (args.length >= fn.length) {\nreturn fn.apply(this, args)\n} else {\nreturn function(...args2) {\ncurried.apply(this, [...args, ...args2]);\n}\n}\n}")]),n._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[n._v("return curried;\n")])])]),_("p",[n._v("}")]),n._v(" "),_("p",[n._v("var m = hyCurring(add);\nm(10, 20, 30, 40)  // 相当于才是 fn fn的this指向也要改变  m 来替代 fn  m.call() 我的绑定你fn要遵循")]),n._v(" "),_("p",[n._v("m(10)")]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("组合函数：是在 js 开发过程中一种对函数的使用技巧、模式：\n对函数的组合，就称为组合函数")]),n._v(" "),_("p",[n._v("组合函数的理解：\nfunction double(num) {\nreturn num * 2\n}\nfunction square(num) {\nreturn num ** 2\n}\nvar count = 10;\nvar result = square(double(count))")]),n._v(" "),_("p",[n._v("var num = 100;\nvar result = square(double(num))")]),n._v(" "),_("p",[n._v("组合 double 和 square")]),n._v(" "),_("p",[n._v("function composeFn(m, n) {\nreturn function(count) {\nreturn n(m(count));\n}\n}\nvar newFn = composeFn(double, square);\nnewFn(10)")]),n._v(" "),_("p",[n._v("function hyCompose(...fns) {\nvar length = fns.length;\nfor (var i = 0; i < length; i++) {\nif (typeof fns[i] !== 'function') {\nthrow new TypeError('Expected arguments are function')\n}\n}\nfunction compose(...args) {\nvar index = 0;\nvar result = length ? fns[index].apply(this, args) : args\nwhile (++index < length) {\nresult = fns[index].call(this, result)\n}\nreturn result;\n}\nreturn compose;\n}")]),n._v(" "),_("p",[n._v("function double(m) {\nreturn m * 2\n}\nfunction square(n) {\nreturn n ** 2\n}\nvar newFn = hyCompose(double, square)\nnewFn(10, 20, 30)")]),n._v(" "),_("p",[n._v("newFn(10, 20, 30)")]),n._v(" "),_("hr")])}),[],!1,null,null,null);v.default=t.exports}}]);