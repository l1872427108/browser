(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{406:function(a,t,v){"use strict";v.r(t);var r=v(56),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"css动画和javascript动画"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css动画和javascript动画"}},[a._v("#")]),a._v(" CSS动画和JavaScript动画")]),a._v(" "),v("p",[a._v("从输入URL到变为页面，我们了解了整个过程。渲染引擎的分层和合成机制，Chrome 对其进行了大量的优化工作。有助于深刻理解CSS动画和JavaScript动画底层工作机制。")]),a._v(" "),v("p",[a._v("在输入URL到变为页面中。需要显卡将合成新的图像保存到后缓冲区，显示器去前缓冲区中读取图像。而每个显示器都有固定的刷新频率，通常是 60 HZ，每秒更新60张图片。")]),a._v(" "),v("p",[a._v("一旦显卡更新频率跟不上显示器读取频率，就会造成丢帧，从而造成视觉上的卡顿。")]),a._v(" "),v("p",[a._v("渲染流水线生成的每一幅图片被称为一帧，把渲染流水线每秒更新多少帧称为帧率。")]),a._v(" "),v("p",[a._v("要解决刷新问题，就需要提高渲染流水线的绘制一帧的效率。Chrome 对浏览器渲染方式做了大量工作，最有成效的就是引入分层和合成机制。")]),a._v(" "),v("h3",{attrs:{id:"如何快速生成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何快速生成"}},[a._v("#")]),a._v(" 如何快速生成")]),a._v(" "),v("p",[a._v("任意一帧的生成方式，有重排、重绘和合成三种方式。渲染路径越长，生成图像花费的时间就越多。")]),a._v(" "),v("p",[a._v("(请看重排、重绘和合成章节)")]),a._v(" "),v("p",[a._v("相比较于重排、重绘，合成操作的路径非常短，如果采用 CPU ，合成效率会更高。")]),a._v(" "),v("p",[a._v("合成操作是在合成线程上完成的，在执行合成操作，是不会影响到主线程的。所以即使主线程卡住了，CSS动画依然能够执行。")]),a._v(" "),v("h3",{attrs:{id:"javascript动画"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript动画"}},[a._v("#")]),a._v(" JavaScript动画")]),a._v(" "),v("p",[a._v("在编写JavaScript来实现动画，会牵扯到整个渲染流水线，所以JavaScript效率非常低下。通过 JavaScript 来修改 CSSOM，会触发整个渲染流水线。")]),a._v(" "),v("p",[a._v("CSS3的动画可以在合成线程上实现，JavaScript都是在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣")]),a._v(" "),v("h3",{attrs:{id:"一个问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一个问题"}},[a._v("#")]),a._v(" 一个问题")]),a._v(" "),v("p",[a._v("利用CSS动画，直接进入合成阶段，那么不会改变吗？")]),a._v(" "),v("p",[a._v("能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变化都不会影响到图层的内容。")]),a._v(" "),v("p",[a._v("如果使用 will-change, 那么会为这些元素单独的一层，在旋转的时候，只要在合成线程将这些box图层整体旋转到设置的角度，再拿旋转后的box图层和北京图层合成一张新图。")])])}),[],!1,null,null,null);t.default=s.exports}}]);