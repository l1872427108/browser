(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{425:function(t,e,s){"use strict";s.r(e);var r=s(56),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"同一站点-输入url网络篇补充"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同一站点-输入url网络篇补充"}},[t._v("#")]),t._v(" 同一站点(输入URL网络篇补充)")]),t._v(" "),s("p",[t._v("我们将“同一站点”定义为根域名, 例如，puge.net, 加上协议（例如，https:// 或者http://）, 还包含了该根域名下的所有子域名和不同的端口.")]),t._v(" "),s("p",[t._v("Chrome的默认策略是，每个标签对应一个渲染进程, 但是如果从一个页面打开了新页面, 而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。当几个页面是符合同一个站点的要求的，那么就会分配到一个渲染进程，所以一个页面崩溃，就会导致这几个相同条件的页面都会崩溃。")]),t._v(" "),s("p",[t._v("那么为什么需要这种机制呢？因为在一个渲染进程里面，他们就会共享 JS 的执行环境，两个页面可以共享执行脚本。这个机制是很有用的。")])])}),[],!1,null,null,null);e.default=n.exports}}]);