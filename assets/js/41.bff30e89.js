(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{439:function(t,v,a){"use strict";a.r(v);var _=a(56),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"资源优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源优化"}},[t._v("#")]),t._v(" 资源优化")]),t._v(" "),a("ol",[a("li",[t._v("减少 http 请求数量，资源越多，在网络上造成的开销就越大。")]),t._v(" "),a("li",[t._v("减少请求资源大小。")])]),t._v(" "),a("h3",{attrs:{id:"图片优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片优化"}},[t._v("#")]),t._v(" 图片优化")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("图片格式的选择, 找一个合适的格式。")]),t._v(" "),a("ul",[a("li",[t._v("jpg/jpeg: 有损压缩的图片，色彩感也不错，色彩高达16000多种，可以满足我们开发的需要。但是不适用一些纹理较强的图片。")]),t._v(" "),a("li",[t._v("png: 可以适用于一些纹理性，边角清晰的使用。但是体积要更大，色彩感丰富，适用于一些小店的图标。")]),t._v(" "),a("li",[t._v("webP: 跟 png 的质量有的一比，提及确实比 png 更小。Google 提倡使用。 兼容性存在一些小问题。\n其实三种都可以，质量方面我们很难看出来区别，所以还是要选择提及小一点的。")])])]),t._v(" "),a("li",[a("p",[t._v("图片加载顺序，注重图片优先级，先把重要的加载进来。")])]),t._v(" "),a("li",[a("p",[t._v("图片的懒加载。")]),t._v(" "),a("ul",[a("li",[t._v('原生懒加载  img 上添加属性 loading="lazy"')]),t._v(" "),a("li",[t._v("借助一些第三方库。 verlok/lazyload    yall.js  blazy.")])])]),t._v(" "),a("li",[a("p",[t._v("渐进式图片。 JPEG 本身的特点")]),t._v(" "),a("ul",[a("li",[t._v("Baseline JPEG 自身而下的加载图片")]),t._v(" "),a("li",[t._v("Progressive JPEG  模糊到清除. 用户体验更好。")])])]),t._v(" "),a("li",[a("p",[t._v("响应式图片。 h5 新添加的属性来可以根据不同的尺寸来选择图片尺寸。 我们尽量不要将大的图片资源，为了在小屏幕上适应而缩小图片大小，这样在小屏幕上加载一个很大的图片，会造成很大的资源浪费。")])]),t._v(" "),a("li",[a("p",[t._v("iconfont")]),t._v(" "),a("ul",[a("li",[t._v("一套字体，减少获取时的请求数量和体积。")]),t._v(" "),a("li",[t._v("矢量图形，可伸缩.")]),t._v(" "),a("li",[t._v("直接通过 css 修改样式（颜色、大小）")]),t._v(" "),a("li",[t._v("iconfont 不能多颜色。")]),t._v(" "),a("li",[t._v("语义感没有。")])])]),t._v(" "),a("li",[a("p",[t._v("svg")]),t._v(" "),a("ul",[a("li",[t._v("保持了图片能力，支持多色彩。")]),t._v(" "),a("li",[t._v("独立的矢量图形。体积更小，不用引入一套。")]),t._v(" "),a("li",[t._v("XML 语法。 SEO/读屏软件读取。")])])])]),t._v(" "),a("h3",{attrs:{id:"字体优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字体优化"}},[t._v("#")]),t._v(" 字体优化")]),t._v(" "),a("p",[t._v("字体未下载完成时，浏览器隐藏或自动降级，导致字体闪动。")]),t._v(" "),a("ol",[a("li",[t._v("FOIT: 文字从看不到到看到")]),t._v(" "),a("li",[t._v("FOUT: 没有经过样式渲染，呈现两种字体。")])]),t._v(" "),a("p",[t._v("当我们网络下载字体，就会遇到这种问题。为了尽早的显示字体，我们需要进行一些调整。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("font-display")]),t._v(" "),a("ul",[a("li",[t._v("block: 3秒等待（不显示）加载完就替换字体，否则就默认字体。")]),t._v(" "),a("li",[t._v("swap  上来默认字体， 直到需要的字体 (很快的看到文字)")]),t._v(" "),a("li",[t._v("fallback  100ms 没有下载完, 就是用默认，下载完就是用下载好的字体。")]),t._v(" "),a("li",[t._v("optional: 浏览器经过100ms判断，如果下载的字体还很慢，就不使用，使用默认字体。就不会做改变了。")])])]),t._v(" "),a("li",[a("p",[t._v("AJAX + Base64 嵌入到 js/css\n兼容性好，通过载入文件里面。但是没有办法控制文字的缓存。")])])]),t._v(" "),a("h3",{attrs:{id:"gzip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gzip"}},[t._v("#")]),t._v(" gzip")]),t._v(" "),a("p",[t._v("对传输资源进行体积压缩，压缩率可高达 90%. 通过 nginx 来开启 gzip。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("gzip on 开启压缩 \ngzip_min_length 1k 最少1k采取压缩\ngzip_comp_level "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(" 压缩登记  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("～"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" 对性能消耗\n对文本压缩。 图片一般不压缩\ngzip_static on 对已经压缩的静态资源直接利用\ngzip_vary on"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  在响应头部添加一个 vary 属性，告诉浏览器端提供了 gzip\ngzip_buffers 优化压缩过程。\ngzip_http_version "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v(" http版本\n")])])]),a("h3",{attrs:{id:"keep-alive-对-tcp-链接请求复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-对-tcp-链接请求复用"}},[t._v("#")]),t._v(" keep alive 对 TCP 链接请求复用")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Initial connection 就是对 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("TCP")]),t._v(" 链接的链接。 \n"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("connection")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" keep"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive。\nkeepalive_timeout "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" 就是关闭。\nkeepalive"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("timeout "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("65")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" 超时的时间。 65s 都没有使用就会关闭\nkeepalive_requests "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  建立 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("TCP")]),t._v(" 一共可以发送多少个请求。\n")])])]),a("h3",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" HTTP 缓存")]),t._v(" "),a("h3",{attrs:{id:"service-workers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-workers"}},[t._v("#")]),t._v(" Service Workers")]),t._v(" "),a("ol",[a("li",[t._v("加载重复访问.")]),t._v(" "),a("li",[t._v("离线支持.")]),t._v(" "),a("li",[t._v("确实是延迟首屏加载时间，但也没总加载时间减少。")]),t._v(" "),a("li",[t._v("兼容性没那么好的。")]),t._v(" "),a("li",[t._v("只能在 localhost 或 https 下使用")])]),t._v(" "),a("h3",{attrs:{id:"http-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" HTTP/2")]),t._v(" "),a("h3",{attrs:{id:"服务端渲染-ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr"}},[t._v("#")]),t._v(" 服务端渲染 SSR")]),t._v(" "),a("ol",[a("li",[t._v("加快首屏加载.")]),t._v(" "),a("li",[t._v("更好的 SEO.")]),t._v(" "),a("li",[t._v("服务端返回已经处理好的 html 页面。")]),t._v(" "),a("li",[t._v("架构-大型，动态页面，面向公众用户。  搜索引擎排名很重要。 场景可能需要使用 SSR")])]),t._v(" "),a("h3",{attrs:{id:"还有什么方法可以提高排名呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#还有什么方法可以提高排名呢"}},[t._v("#")]),t._v(" 还有什么方法可以提高排名呢？")]),t._v(" "),a("p",[t._v("可以前面的页面用静态页面，后面采用 vue 、react 这种。")]),t._v(" "),a("h3",{attrs:{id:"资源加载顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源加载顺序"}},[t._v("#")]),t._v(" 资源加载顺序")]),t._v(" "),a("p",[t._v("preload, prefetch 调整优先级.")]),t._v(" "),a("p",[t._v("每一个资源都有一个 priority 属性，代表的是资源的优先级。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("preload:")]),t._v(" "),a("ul",[a("li",[t._v("提前加载较晚出现，但对当前页面非常重要的资源。")]),t._v(" "),a("li",[t._v("preload 只负责加载，不负责解析。")])])]),t._v(" "),a("li",[a("p",[t._v("prefetch:")]),t._v(" "),a("ul",[a("li",[t._v("提前加载资源，但是不是对当前页面有用的。")]),t._v(" "),a("li",[t._v("这样子当其他页面用到，会从 prefetch cache 去获取缓存。")])])])]),t._v(" "),a("h3",{attrs:{id:"预渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预渲染"}},[t._v("#")]),t._v(" 预渲染")]),t._v(" "),a("ol",[a("li",[t._v("大型单页应用的性能瓶颈： JS 下载 + 解析 + 执行。")]),t._v(" "),a("li",[t._v("SSR 主要的问题：权衡的一种方式，牺牲 TTFB 来补救 First Paint\nTTFB 请求后台，包括从后台拿过来的时间，包括后台处理的时间。传输的过程中也会增加。实现复杂。")]),t._v(" "),a("li",[t._v("预渲染  打包时提前渲染页面，没有服务端的参与。 打包的时候提前一个渲染。但是没有 SSR 那么 完美。")])]),t._v(" "),a("h3",{attrs:{id:"windowing-窗口化-提高列表性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#windowing-窗口化-提高列表性能"}},[t._v("#")]),t._v(" windowing(窗口化)提高列表性能")]),t._v(" "),a("p",[t._v("只给用户能够看到的表格或列。")]),t._v(" "),a("p",[t._v("不创建无限多的元素，复用每一行的组件，把不使用的回收，再去创建。")]),t._v(" "),a("p",[t._v("作用： 加载大列表、大表单的每一行严重影响性能。")]),t._v(" "),a("p",[t._v("懒加载会让 DOM 变的过大。")]),t._v(" "),a("p",[t._v("windowing 只渲染可见的行，渲染和滚动的性能都会提升。")]),t._v(" "),a("h3",{attrs:{id:"骨架屏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#骨架屏"}},[t._v("#")]),t._v(" 骨架屏")]),t._v(" "),a("p",[t._v("减少布局移动。")]),t._v(" "),a("p",[t._v("占位。加载完之后再去渲染, 提高用户感知性能。")])])}),[],!1,null,null,null);v.default=s.exports}}]);