(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{416:function(e,r,v){"use strict";v.r(r);var _=v(56),t=Object(_.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"pwa"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pwa"}},[e._v("#")]),e._v(" PWA")]),e._v(" "),v("h3",{attrs:{id:"浏览器的进化路线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的进化路线"}},[e._v("#")]),e._v(" 浏览器的进化路线")]),e._v(" "),v("ul",[v("li",[e._v("Web 化")]),e._v(" "),v("li",[e._v("Web 应用移动化")]),e._v(" "),v("li",[e._v("Web 操作系统化")])]),e._v(" "),v("p",[e._v("Web 应用移动化是 Google 一直致力于发展的一件事情，不过对于移动设备来说, 前有APP、后有移动小程序。浏览器的运行性能低于它们。")]),e._v(" "),v("h3",{attrs:{id:"什么是-pwa"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-pwa"}},[e._v("#")]),e._v(" 什么是 PWA")]),e._v(" "),v("p",[e._v("PWA（Progressive Web App），渐进式网页应用。")]),e._v(" "),v("ul",[v("li",[e._v("站在 Web 应用开发者来说，PWA 提供一个渐进式的过渡方案，让 Web 应用逐步具有本地应用的能力。采用渐进式可以降低站点改造的代价。")]),e._v(" "),v("li",[e._v("站在技术角度来说，PWA 技术是一个渐进式的演化过程，逐渐的提供更好的设备特效支持，不断优化更加流畅的动画效果，不断让页面的加载速度变的更快，不断实现本地应用的特性。")])]),e._v(" "),v("p",[e._v("Web 最大的优势就是自由开放，更容易被接受.")]),e._v(" "),v("p",[e._v("PWA 是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或小程序的距离。")]),e._v(" "),v("h3",{attrs:{id:"web-vs-本地应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#web-vs-本地应用"}},[e._v("#")]),e._v(" Web VS 本地应用")]),e._v(" "),v("ul",[v("li",[e._v("Web 缺少离线使用能力，在离线或弱网环境下基本上无法使用。")]),e._v(" "),v("li",[e._v("Web 应用缺少消息推送的能力。APP 厂商，需要有将消息送到应用的能力。")]),e._v(" "),v("li",[e._v("Web 不能够将 Web 安装到桌面。")])]),e._v(" "),v("p",[e._v("针对以上，PWA 提出两种解决方案：通过引入 Service Worker 解决离线缓存和消息推送的问题。引入 manifest.json 解决安装桌面问题。")]),e._v(" "),v("h3",{attrs:{id:"service-worker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[e._v("#")]),e._v(" Service Worker")]),e._v(" "),v("p",[e._v("Service Worker 之前，WHATWG 小组推出过使用 APP Cache 标准来缓存页面。但是 App Cache 暴露出来的问题太多。")]),e._v(" "),v("p",[e._v("2014 年，标准委员会提出了 Service Worker。主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。")]),e._v(" "),v("img",{attrs:{src:"/browser/service.webp",width:"800",height:"500"}}),e._v(" "),v("p",[e._v("Service Worker 主要功能就是拦截请求和缓存资源。")]),e._v(" "),v("ul",[v("li",[e._v("架构\n为了避免 js 过多的占用页面主线程过长的情况，浏览器实现了 Web Worker 的功能。Web Worker 目的是让 js 能够运行在页面主线程之外，不过由于 Web Worker 中没有当前页面的 DOM 环境，通过 postMessage 方法将执行的结果返回给主线程。Web Worker 是渲染进程新开的一个线程，生命周期和页面无关。")])]),e._v(" "),v("p",[e._v("让其运行在主线程之外，就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 js 脚本执行完成后都会推出，执行结果不能保存下来，如果下次还有同样操作，就得重新来一遍，Service Worker 需要在 Web Worker 的基础之上增加存储功能。")]),e._v(" "),v("p",[e._v("由于 Service Worker 需要为多个页面服务，在目前的 Chrome 架构中，Service Worker 运行在浏览器进程中的。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("消息推送\n消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，需要 Service Worker 来接受服务器推送的消息，并将消息通过一定方式展示给用户。")])]),e._v(" "),v("li",[v("p",[e._v("安全\n核心的一条就是 HTTP，明文传输信息，存在窃听、串改和被劫持的风险。所以，Service Worker 采用 HTTPS，数据都是经过加密的，即使拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被串改。")])])]),e._v(" "),v("p",[e._v("Service Worker 还需要同时支持 Web 页面默认的安全策略(同源策略、内容安全策略)。")])])}),[],!1,null,null,null);r.default=t.exports}}]);