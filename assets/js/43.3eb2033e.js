(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{442:function(t,v,a){"use strict";a.r(v);var r=a(56),_=Object(r.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"输入url到加载经历了什么-渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入url到加载经历了什么-渲染"}},[t._v("#")]),t._v(" 输入URL到加载经历了什么 --- 渲染")]),t._v(" "),a("p",[t._v("在解析阶段经过了DOM生成、样式计算和布局阶段")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#分层"}},[t._v("分层")])]),a("li",[a("a",{attrs:{href:"#图层绘制"}},[t._v("图层绘制")])]),a("li",[a("a",{attrs:{href:"#栅格化-raster-操作"}},[t._v("栅格化（raster）操作")])]),a("li",[a("a",{attrs:{href:"#合成和显示"}},[t._v("合成和显示")])])])]),a("p"),t._v(" "),a("h3",{attrs:{id:"分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" 分层")]),t._v(" "),a("p",[t._v("如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。 为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" "),a("p",[t._v("浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。")]),t._v(" "),a("p",[t._v("那么什么时候会单独的提升为图层呢？")]),t._v(" "),a("ol",[a("li",[a("font",{attrs:{size:"3",color:"#dd0000"}},[t._v("拥有层叠上下文属性的元素会被提升为单独的一层")]),a("br")],1)]),t._v(" "),a("ul",[a("li",[a("code",[t._v("HTML 根元素本身就是具有层叠上下文.")])]),t._v(" "),a("li",[a("code",[t._v("position值absolute 或 relative, 且z-index为auto")])]),t._v(" "),a("li",[a("code",[t._v("position值 fixed 或 sticky")])]),t._v(" "),a("li",[a("code",[t._v("flex容器的子元素，且 z-index 不为 auto")])]),t._v(" "),a("li",[a("code",[t._v("元素的 opacity 的值不是 1.")])]),t._v(" "),a("li",[a("code",[t._v("元素的 transform 不为 none.")])]),t._v(" "),a("li",[a("code",[t._v("元素的 filter 值不是 none。")])]),t._v(" "),a("li",[a("code",[t._v("will-change 指定的属性值为上面的任意一个")]),t._v("。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("font",{attrs:{size:"3",color:"#dd0000"}},[t._v("需要裁剪的地方")]),a("br"),t._v("\n比如一个 div，里面的文字太多，需要被裁减，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条会被单独提升为一个图层。")],1)]),t._v(" "),a("h3",{attrs:{id:"图层绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" 图层绘制")]),t._v(" "),a("p",[t._v("接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描述边框，然后将这些指令按照顺序组合成一个待绘制的列表。")]),t._v(" "),a("p",[t._v("当查看 Chrome 的 Layers 面板，就能够办看绘制列表。")]),t._v(" "),a("h3",{attrs:{id:"栅格化-raster-操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栅格化-raster-操作"}},[t._v("#")]),t._v(" 栅格化（raster）操作")]),t._v(" "),a("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表, 而实际上绘制操作是由渲染引擎中的合成线程来完成的.")]),t._v(" "),a("p",[t._v("当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程.")]),t._v(" "),a("h4",{attrs:{id:"分块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块"}},[t._v("#")]),t._v(" "),a("font",{attrs:{size:"3",color:"#dd0000"}},[t._v("分块")])],1),t._v(" "),a("p",[t._v("如果说分层式宏观上的Chrome对生成图片的优化，那么分块就是微观上的优化。")]),t._v(" "),a("p",[t._v("首先，考虑到视口就这么大（用户能够看到的部分），当页面非常大的时候，要滑很长的时间才能够到底，如果一次性全部绘制出来时相当的耗费性能的。因此合成线程会将图层划分为图块，这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。")]),t._v(" "),a("p",[t._v("显示一个页面时，如果等待所有的图层都生成好之后，在进行合成的话，会产生一些不必要的开销，会让合成图片的时间变的更久, 合成线程会按照视口附近的图块来优先生成位图.")]),t._v(" "),a("h4",{attrs:{id:"位图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位图"}},[t._v("#")]),t._v(" "),a("font",{attrs:{size:"3",color:"#dd0000"}},[t._v("位图")])],1),t._v(" "),a("p",[t._v("实际生成位图的操作时由栅格化来执行的, 而图块是栅格化执行的最小单位. 渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在线程池内执行的。")]),t._v(" "),a("p",[t._v("通常，栅格化过程都会使用 GPU 来加速生成的，使用 GPU 生成位图的过程叫做快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。")]),t._v(" "),a("p",[t._v("要使用 GPU，就涉及到跨进程操作，GPU 操作运行在 GPU 进程中。GPU将生成位图，并且保存在 GPU 内存中")]),t._v(" "),a("p",[a("font",{attrs:{size:"2",color:"#dd0000"}},[t._v("小知识点：")]),t._v(" "),a("code",[t._v("考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也会耗费大量的时间。针对这个问题，Chrome 采用了一个策略：在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的拖，这个时候继续进行合成操作，当正常的图块绘制完毕之后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。")])],1),t._v(" "),a("h3",{attrs:{id:"合成和显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[t._v("#")]),t._v(" 合成和显示")]),t._v(" "),a("p",[t._v("一旦所有图块都被光栅化, 合成线程就会生成一个绘制图块的命令---DrawQuad, 然后将该命令提交给浏览器进程。")]),t._v(" "),a("p",[t._v("浏览器进程中的 viz 组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这个内容发送给显卡。")]),t._v(" "),a("p",[t._v("每个显示器都有固定的刷新频率，通常是 60 HZ，每秒更新 60 张图片，更新的图片都是来自于显卡中的前缓冲区的地方。显示器所做的事情，就是每秒固定读取 60 次前缓冲区的图像。并显示到显示器上。")]),t._v(" "),a("p",[t._v("显卡所做的就是合成新的图像，并将图像保存到后缓存区，一旦显卡把合成的图像写到后缓存区，系统就会让后缓冲区和前缓冲区互换，如此循环更新。保证显示器能够读取到最新合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但是有些复杂的场景中，显卡处理一张图片的速度会变慢，导致多次读取的图像是上一次的，就会造成视觉上的卡顿。")]),t._v(" "),a("p",[t._v("到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。")])])}),[],!1,null,null,null);v.default=_.exports}}]);