(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{444:function(t,e,v){"use strict";v.r(e);var a=v(56),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"输入url到加载经历了什么-解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#输入url到加载经历了什么-解析"}},[t._v("#")]),t._v(" 输入URL到加载经历了什么 --- 解析")]),t._v(" "),v("p",[t._v("弄懂渲染阶段可以更加看透页面是如何工作的；可能使用开发者工具分析优化页面卡顿问题，使用 JavaScript 优化动画流程等。")]),t._v(" "),v("p",[v("code",[t._v("结合这个过程来看回流章节、阻塞章节、页面声明周期、css动画和js动画更高效等")])]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#渲染流程"}},[t._v("渲染流程")])]),v("li",[v("a",{attrs:{href:"#构建-dom-树-结合-如何构建dom树过程"}},[t._v("构建 DOM 树(结合 如何构建DOM树过程)")])]),v("li",[v("a",{attrs:{href:"#样式计算-recalculate-style"}},[t._v("样式计算（Recalculate Style）")])]),v("li",[v("a",{attrs:{href:"#布局计算"}},[t._v("布局计算")])])])]),v("p"),t._v(" "),v("h3",{attrs:{id:"渲染流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程"}},[t._v("#")]),t._v(" 渲染流程")]),t._v(" "),v("p",[t._v("通过输入 HTML、CSS、JavaScript 数据，经过渲染模块的处理，输出为屏幕上的像素")]),t._v(" "),v("p",[t._v("渲染模块在执行过程中会被划分为很多个子阶段。这个处理流程叫做渲染流水线（回流的根本原因就是渲染流水线重复做的事情多）")]),t._v(" "),v("p",[t._v("子阶段的特征：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("每个子阶段都有其输入的内容")])]),t._v(" "),v("li",[v("code",[t._v("然后每个阶段有其处理过程")])]),t._v(" "),v("li",[v("code",[t._v("最终每个子阶段会生成输出内容")])])]),t._v(" "),v("h3",{attrs:{id:"构建-dom-树-结合-如何构建dom树过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树-结合-如何构建dom树过程"}},[t._v("#")]),t._v(" 构建 DOM 树(结合 如何构建DOM树过程)")]),t._v(" "),v("p",[t._v("浏览器无法直接理解和使用 HTML, 所以需要将 HTML 转换为浏览器能够理解的结构 ---- DOM 树。")]),t._v(" "),v("p",[t._v("构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。")]),t._v(" "),v("p",[t._v("通过在 Chrome 开发者工具，通过在 Console 中输入 document 来看完整的 DOM 树结构")]),t._v(" "),v("p",[t._v("DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。")]),t._v(" "),v("h3",{attrs:{id:"样式计算-recalculate-style"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#样式计算-recalculate-style"}},[t._v("#")]),t._v(" 样式计算（Recalculate Style）")]),t._v(" "),v("ol",[v("li",[t._v("关于 CSS 样式，来源:")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("link 标签引用。")])]),t._v(" "),v("li",[v("code",[t._v("style 标签中的样式。")])]),t._v(" "),v("li",[v("code",[t._v("元素的内嵌 style 属性。")])])]),t._v(" "),v("p",[t._v("当渲染引擎接收到 CSS 文本时, 会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。")]),t._v(" "),v("p",[t._v("可以通过 Chrome 控制台输入 document.styleSheets ,并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[t._v("转换样式表中的属性值，使其标准化.\n有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此在进行样式计算之前将他们标签化。\nem -> px, red -> #ff0000, blod->700 等等。")])]),t._v(" "),v("li",[v("p",[t._v("计算出 DOM 树中每个节点的具体样式\n将样式进行格式化和标签化之后，接下来就是计算每个节点的具体样式信息。涉及到 CSS 的继承规则和层叠规则")])])]),t._v(" "),v("ul",[v("li",[t._v("首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式, 如果父节点中没有找到，就会采用浏览器的默认样式，也叫 UserAgent 样式。")]),t._v(" "),v("li",[t._v("样式计算过程中的第二个规则是样式层叠, 就是最终的样式取决于各个属性共同作用的效果。")]),t._v(" "),v("li",[t._v("在计算完样式之后，这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。会被挂载到 window.getComputedStyle 当中可以通过 js 来获取计算后的样式。")])]),t._v(" "),v("h3",{attrs:{id:"布局计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布局计算"}},[t._v("#")]),t._v(" 布局计算")]),t._v(" "),v("p",[t._v("在生成了 DOM 树和 DOM 样式，接下来就是通过浏览器的布局系统确定元素的位置，要生成一颗 布局树。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("创建布局树\nDOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树, 它会遍历生成的 DOM 树节点，把他们添加到 布局树中。")])]),t._v(" "),v("li",[v("p",[t._v("布局计算\n现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是一个不合理的地方。Chrome团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。")])])]),t._v(" "),v("p",[t._v("styleSheets 类似于早之前的 CSSOM，是会先生成一颗 Render Tree ，渲染树，但是 Chrome 进行了大量的重构，已经没有生成 Render Tree 的过程了。")])])}),[],!1,null,null,null);e.default=_.exports}}]);